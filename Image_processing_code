`timescale 1ns / 1ps // Added timescale for consistent simulation

module axi_cpu_master (
    input wire clk, rst_n, start,
    output reg [31:0] awaddr, wdata,
    output reg awvalid, wvalid, wlast, bready,
    output reg [3:0] wstrb,
    input wire awready, wready, bvalid,
    input wire [1:0] bresp
);

    // Burst counter to keep track of the number of transfers in a burst.
    // Since we are sending 64 bytes (0 to 63), a 6-bit counter is sufficient.
    reg [5:0] burst_cnt;
    // Array to store 64 bytes of image data. Each element is 8 bits.
    reg [7:0] image_data [0:63];
    // State register for the FSM (Finite State Machine).
    reg [1:0] state;

    // Local parameters for FSM states.
    localparam IDLE = 2'b00;      // Initial state, waiting for 'start' signal.
    localparam SEND_AW = 2'b01;   // Sending AXI Write Address.
    localparam SEND_W = 2'b10;    // Sending AXI Write Data.
    localparam WAIT_B = 2'b11;    // Waiting for AXI Write Response.

    // Initialize image_data from a memory file.
    // This will load the hexadecimal values from 'image_block.mem' into the array.
    initial $readmemh("image_block.mem", image_data);

    // Main FSM logic, sensitive to positive clock edge and negative reset edge.
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Reset state: All outputs are de-asserted, state goes to IDLE.
            state <= IDLE;
            awaddr <= 0;
            awvalid <= 0;
            wdata <= 0;
            wvalid <= 0;
            wlast <= 0;
            wstrb <= 4'h0; // No byte lanes enabled
            bready <= 0;
            burst_cnt <= 0;
        end else begin
            // FSM transitions based on current state and AXI handshake signals.
            case (state)
                IDLE: begin
                    // In IDLE state, wait for 'start' signal.
                    // Keep AXI signals de-asserted.
                    awvalid <= 0;
                    wvalid <= 0;
                    bready <= 0;
                    wlast <= 0; // Ensure wlast is low
                    if (start) begin
                        // When 'start' is high, initiate a write transaction.
                        awaddr <= 32'h00001000; // Set the base address for the write.
                        awvalid <= 1;           // Assert AWVALID to indicate a valid address.
                        state <= SEND_AW;       // Move to SEND_AW state.
                    end
                end
                SEND_AW: begin
                    // In SEND_AW state, wait for AWREADY from the slave.
                    if (awready) begin
                        // If AWREADY is high, address has been accepted.
                        awvalid <= 0;           // De-assert AWVALID.
                        burst_cnt <= 0;         // Reset burst counter for data phase (points to image_data[0]).
                        // Prepare the first data word (image_data[0]).
                        wdata <= {24'd0, image_data[0]};
                        wstrb <= 4'hF;          // Enable all 4 byte lanes.
                        wvalid <= 1;            // Assert WVALID to indicate valid write data.
                        wlast <= (0 == 6'd63);  // WLAST is high if this is the only data.
                        state <= SEND_W;        // Move to SEND_W state.
                    end else begin
                        // If AWREADY is not high, keep AWVALID asserted.
                        awvalid <= 1;
                    end
                end
                SEND_W: begin
                    // In SEND_W state, send data words.
                    // Data is sent when WVALID and WREADY are both high.
                    if (wvalid && wready) begin
                        // Current data (image_data[burst_cnt]) has been accepted by the slave.
                        if (burst_cnt == 6'd63) begin // If this was the last data element (index 63)
                            wvalid <= 0; // De-assert WVALID as the burst is complete.
                            wlast <= 1;  // Ensure WLAST is asserted for this final transfer.
                            state <= WAIT_B; // Move to wait for the write response.
                        end else begin
                            // Not the last data element, prepare for the next transfer.
                            burst_cnt <= burst_cnt + 1; // Increment counter for the next data index.
                            wdata <= {24'd0, image_data[burst_cnt + 1]}; // Load the next data (image_data[new_burst_cnt]).
                            wlast <= (burst_cnt + 1 == 6'd63); // Check if the *next* data will be the last.
                            wvalid <= 1; // Keep WVALID asserted for the next transfer.
                        end
                    end else if (wvalid && !wready) begin
                        // If WVALID is high but WREADY is low, slave is not ready.
                        // Keep current data and WVALID asserted, wait for slave.
                        wvalid <= 1;
                    end
                end
                WAIT_B: begin
                    // In WAIT_B state, wait for the BVALID response from the slave.
                    bready <= 1; // Assert BREADY to indicate readiness to accept response.
                    if (bvalid) begin
                        // If BVALID is high, response has been received.
                        bready <= 0;    // De-assert BREADY.
                        state <= IDLE;  // Go back to IDLE state, ready for next transaction.
                    end
                end
                default: begin
                    // Should not happen, but good practice to handle unexpected states.
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule

// gpu_axi_slave.v
// This module acts as an AXI slave to receive image data.
// It stores the received 8-bit data into an internal buffer.

`timescale 1ns / 1ps // Added timescale for consistent simulation

module gpu_axi_slave (
    input wire clk, rst_n,
    input wire [31:0] awaddr, wdata,
    input wire awvalid, wvalid, wlast, bready,
    input wire [3:0] wstrb, // Not used in this simple slave, but good to keep for AXI compliance.
    output reg awready, wready, bvalid,
    output reg [1:0] bresp,
    input wire [5:0] pixel_index, // Input to select which pixel to output.
    output reg [7:0] pixel_out    // Output the selected pixel data.
);

    // Internal buffer to store the received image data.
    reg [7:0] gpu_buffer [0:63];
    // Pointer to the current write location in the buffer.
    reg [5:0] write_ptr;
    // State register for the FSM.
    reg [1:0] state;

    // Corrected: Declare loop variable 'i' as reg outside the initial block
    reg [6:0] i; // 'i' needs to be wide enough for 0 to 63, so 6 bits is enough (0 to 2^6-1 = 63)

    // Local parameters for FSM states.
    localparam IDLE = 2'b00;   // Initial state, waiting for AXI address.
    localparam WRITE = 2'b01;  // Receiving AXI write data.
    localparam RESP = 2'b10;   // Sending AXI write response.

    // Main FSM logic, sensitive to positive clock edge and negative reset edge.
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Reset state: All outputs de-asserted, state goes to IDLE.
            awready <= 0;
            wready <= 0;
            bvalid <= 0;
            bresp <= 2'b00; // OKAY response
            state <= IDLE;
            write_ptr <= 0;
            // Initialize gpu_buffer to 0s on reset
            for (i = 0; i < 64; i = i + 1) begin // Corrected: Removed 'int' keyword
                gpu_buffer[i] <= 0;
            end
        end else begin
            // FSM transitions based on current state and AXI handshake signals.
            case (state)
                IDLE: begin
                    awready <= 1; // Always ready to accept an address.
                    wready <= 0;  // Not ready for data yet.
                    bvalid <= 0;  // No response to send.
                    if (awvalid) begin
                        // If AWVALID is high, address is received.
                        awready <= 0;       // De-assert AWREADY.
                        state <= WRITE;     // Move to WRITE state.
                        write_ptr <= 0;     // Reset write pointer.
                    end
                end
                WRITE: begin
                    awready <= 0; // Not ready for new address while writing data.
                    wready <= 1;  // Always ready to accept data.
                    bvalid <= 0;  // No response to send yet.
                    if (wvalid && wready) begin
                        // If WVALID and WREADY are high, data is valid and accepted.
                        // Store the least significant 8 bits of wdata into the buffer.
                        gpu_buffer[write_ptr] <= wdata[7:0];
                        write_ptr <= write_ptr + 1; // Increment write pointer.
                        if (wlast) begin
                            // If WLAST is high, this is the last data word.
                            wready <= 0;    // De-assert WREADY.
                            state <= RESP;  // Move to RESP state.
                        end
                    end
                end
                RESP: begin
                    awready <= 0; // Not ready for new address.
                    wready <= 0;  // Not ready for data.
                    bvalid <= 1;  // Assert BVALID to send a response.
                    bresp <= 2'b00; // OKAY response.
                    if (bready) begin
                        // If BREADY is high, response has been accepted.
                        bvalid <= 0;    // De-assert BREADY.
                        state <= IDLE;  // Go back to IDLE state.
                    end
                end
                default: begin
                    // Should not happen, but good practice to handle unexpected states.
                    state <= IDLE;
                end
            endcase
        end
    end

    // Combinational logic to output the pixel data based on pixel_index.
    // This allows reading from the GPU buffer at any time.
    always @(*) begin
        pixel_out = gpu_buffer[pixel_index];
    end
endmodule
